/**
   Copyright 2011 Mavens Consulting, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */

@isTest
public with sharing class {{className}} {
    public static final Boolean FillAllFields = false;

    // Key: SObject API name (e.g. 'Account')
    // Value: Map<String, Schema.SObjectField>, field map (k: fieldName, v: Schema.SObjectField)
    public static final Profile UserProfile = [
        SELECT Id
        FROM Profile
        WHERE Name = 'System Administrator'
    ];

    private static final Map<String, Map<String, Schema.SObjectField>> FieldMapCache =
        new Map<String, Map<String, Schema.SObjectField>>();

    private static final Map<String, Schema.SObjectType> GlobalDescribe =
        Schema.getGlobalDescribe();

    private static final Map<String, SObject> SObjectCache =
        new Map<String, SObject>();

    // When Country and State Picklists are enabled, cannot dynamically resolve
    // which States are within a Country. For that reason, we select values from
    // a limited, pre-defined set of countries and an associated set of states.

    private static Integer currentCountryIndex = 0;
    private static Integer currentStateIndex = 0;
    private final static Integer NumCountries = 3;
    private final static Integer NumStates = 4;
    private final static List<String> CountryCodes = new List<String> {
        'CA',
        'MX',
        'US'
    };
    private final static Map<String, String> CountryNameForCode =
        new Map<String, String> {
            'CA' => 'Canada',
            'MX' => 'Mexico',
            'US' => 'United States'
        };
    private final static Map<String, List<String>> StateCodesForCountryCode =
        new Map<String, List<String>> {
            'CA' => new List<String> {
                'AB',
                'BC',
                'SK',
                'QC'
            },
            'MX' => new List<String> {
                'MI',
                'OA',
                'PU',
                'QR'
            },
            'US' => new List<String> {
                'AL',
                'FL',
                'LA',
                'TX'
            }
        };
    private final static Map<String, String> StateNameForCode =
        new Map<String, String> {
            'AB' => 'Alberta',
            'BC' => 'British Columbia',
            'SK' => 'Saskatchewan',
            'QC' => 'Quebec',
            'MI' => 'Michoacan',
            'OA' => 'Oaxaca',
            'PU' => 'Puebla',
            'QR' => 'Quintana Roo',
            'AL' => 'Alabama',
            'FL' => 'Florida',
            'LA' => 'Louisiana',
            'TX' => 'Texas'
        };

    // Key: '{SObjectType name}.{SObjectField name}'
    // Value: list of possible pick-list values
    private static final Map<String, List<Schema.PicklistEntry>> PicklistValues =
        new Map<String, List<Schema.PicklistEntry>>();

    // Can't use `Schema.SObjectType` as keys, use object name string instead
    public static final Map<String, Set<String>> ExcludedFields = new Map<String, Set<String>> {
        'All' => new Set<String> {
            'CreatedById',
            'CreatedDate',
            'LastModifiedById',
            'LastModifiedDate',
            'OwnerId'
        },
        'Account' => new Set<String> {
            'FirstName',
            'LastName'
        },
        'User' => new Set<String> {
            'CallCenterId',
            'ContactId',
            'DelegatedApproverId',
            'FederationIdentifier',
            'IsActive',
            'ManagerId',
            'UserRoleId'
        }
    };

    // Include nillable fields
    public static final Map<String, Set<String>> IncludedFields = new Map<String, Set<String>> {
        'ContentVersion' => new Set<String> {
            'ContentUrl'
        }
    };

    public static SObject createSObject(String objectType) {
        return createSObject(objectType, false);
    }

    public static List<SObject> createSObjectList(
        String objectType,
        Boolean cascade,
        Integer numberOfObjects
    ) {
        return createSObjectList(objectType, cascade, 0, numberOfObjects);
    }

    public static List<SObject> createSObjectList(
        final String objectType,
        final Boolean cascade,
        final Integer initialCounter,
        final Integer numberOfObjects
    ) {
        final List<SObject> sos = new List<SObject>();
        for (Integer i = 0; i < numberOfObjects; i++) {
            SObjectCache.clear();
            sos.add(createSObject(objectType, cascade, initialCounter + i));
        }
        return sos;
    }

    private static SObject newInstance(final String objectType) {
        final Schema.sObjectType token = GlobalDescribe.get(objectType);
        if (token == null) {
            throw new IllegalArgumentException('Unsupported ObjectType ' + objectType);
        }

        if (!token.getDescribe().isCreateable()) {
            System.debug(String.format(
                'Type "{0}" is not createable, setting to "null"',
                new List<String> {
                    objectType
                }
            ));
            return null;
        }

        return token.newSObject();
    }

    private static SObject getSObjectFromCache(
        final String objectType,
        final Boolean isRoot
    ) {
        if (!SObjectCache.containsKey(objectType)) {
            final SObject obj = newInstance(objectType);
            SObjectCache.put(objectType, obj);
            return obj;
        }

        System.debug(String.format(
            'Retrieving cached instance of type {0}',
            new List<String> {
                objectType
            }
        ));

        final SObject obj = SObjectCache.get(objectType);
        if (obj != null && obj.Id == null && !isRoot) {
            System.debug(String.format(
                'Persisting cached object of type "{0}" since ' +
                'it\'s only in memory and doesn\'t have an ID yet',
                new List<String> {
                    objectType
                }
            ));
            insert obj;
            SObjectCache.put(objectType, obj);
        }

        return obj;
    }

    public static SObject createSObject(
        final String objectType,
        final Boolean cascade,
        final Integer counter
    ) {
        return createSObject(objectType, cascade, counter, true);
    }

    public static SObject createSObject(
        final String objectType,
        final Boolean cascade,
        final Integer counter,
        final Boolean isRoot
    ) {
        final SObject obj = getSObjectFromCache(objectType, isRoot);
        if (obj == null || obj.Id != null) {
            return obj;
        }

        for (Schema.SObjectField field : fieldMapFor(objectType).values()) {
            setFieldValue(obj, field, cascade, counter);
        }

        if (obj.Id == null && !isRoot) {
            System.debug('Inserting child node ' + obj);
            insert obj;
        }

        SObjectCache.put(objectType, obj);
        return obj;
    }

    public static SObject createSObject(
        final String objectType,
        final Boolean cascade
    ) {
        return createSObject(objectType, cascade, 1);
    }

    /**
     * Returns a field map for a given SObject.
     *
     * Note: this method is kept public for test cases to share
     * the same field map info, without requiring a field description.
     *
     * @param {String} objectType SObject API name (e.g. `Account`)
     * @returns a map where the keys are the names of the SObject fields,
     * and the values are their corresponding `Schema.SObjectField` object
     */
    public static Map<String, Schema.SObjectField> fieldMapFor(final String objectType) {
        final String normalizedObjectType = objectType.toLowerCase();
        if (FieldMapCache.containsKey(normalizedObjectType)) {
            return FieldMapCache.get(normalizedObjectType);
        }

        final Map<String, Schema.SObjectField> fieldMap = GlobalDescribe
            .get(objectType)
            .getDescribe()
            .fields
            .getMap();

        // Cache it for next use
        FieldMapCache.put(normalizedObjectType, fieldMap);

        return fieldMap;
    }

    static String getNewPicklistValue(
        final SObject obj,
        final Schema.SObjectField field
    ) {
        final Schema.SObjectType objectType = obj.getSObjectType();
        final Schema.DescribeFieldResult fieldDescribe = field.getDescribe();
        final String key = String.format(
            '{0}.{1}',
            new List<String> {
                String.valueOf(objectType),
                fieldDescribe.getName()
            }
        );

        if (!PicklistValues.containsKey(key)) {
            final List<Schema.PicklistEntry> entries = fieldDescribe.getPicklistValues();
            final String value = entries.size() > 0 ? entries[0].getValue() : null;
            PicklistValues.put(key, entries);
        }

		final List<Schema.PicklistEntry> entries = PicklistValues.get(key);
        if (entries.size() <= 0) {
            return null;
        }

        final Object currentValue = obj.get(field);
        final String currentValueStr = currentValue == null ? null : currentValue.toString();
        for (Schema.PicklistEntry entry : entries) {
            final String value = entry.getValue();
            if (value != currentValueStr) {
                return value;
            }
        }

        // Unfortunately there are no more alternative values in the picklist,
        // so the only alternative is returning `null`, but only if the field
        // itself supports it
        return fieldDescribe.isNillable() ? null : currentValueStr;
    }

    static String getNewCountryCode() {
        currentCountryIndex = Math.mod(currentCountryIndex + 1, NumCountries);
        return CountryCodes.get(currentCountryIndex);
    }

    static String getNewCountry() {
        final String countryCode = getNewCountryCode();
        return CountryNameForCode.get(countryCode);
    }

    static String getNewStateCode() {
        final String currentCountryCode = CountryCodes.get(currentCountryIndex);
        currentStateIndex = Math.mod(currentStateIndex + 1, NumStates);
        return StateCodesForCountryCode
            .get(currentCountryCode)
            .get(currentStateIndex);
    }

    static String getNewState() {
        final String stateCode = getNewStateCode();
        return StateNameForCode.get(stateCode);
    }

    static Boolean isExcludedField(final Schema.DescribeFieldResult fieldDescribe) {
        return ExcludedFields
            .get('All')
            .contains(fieldDescribe.getName());
    }

    static Boolean isExcludedField(
        final SObject obj,
        final Schema.DescribeFieldResult fieldDescribe
    ) {
        final String objectTypeName = obj
            .getSObjectType()
            .getDescribe()
            .getName();
        final Set<String> fields = ExcludedFields.get(objectTypeName);
        return fields == null ? false : fields.contains(fieldDescribe.getName());
    }

    static Boolean isIncludedField(
        final SObject obj,
        final Schema.DescribeFieldResult fieldDescribe
    ) {
        final String objectTypeName = obj
            .getSObjectType()
            .getDescribe()
            .getName();
        final Set<String> fields = IncludedFields.get(objectTypeName);
        return fields == null ? false : fields.contains(fieldDescribe.getName());
    }

    static Boolean isPersonAccountField(final Schema.DescribeFieldResult fieldDescribe) {
        final Boolean isPersonAccountEnabled = fieldMapFor('Account').get('IsPersonAccount') != null;
        final Set<string> skipPersonAccountFields = new Set<string> {
            'Salutation'
        };

        final Boolean CustomPerson = (
            fieldDescribe.isCustom() &&
            fieldDescribe.getName().endsWith('pc')
        );
        final Boolean StandardPerson = (
            !fieldDescribe.isCustom() &&
            fieldDescribe.getName().startsWith('Person')
        );

        return (
            CustomPerson ||
            StandardPerson ||
            (isPersonAccountEnabled && skipPersonAccountFields.contains(fieldDescribe.getName()))
        );
    }

    static void setFieldValue(
        final SObject obj,
        final Schema.SObjectField field,
        final Boolean cascade
    ) {
        setFieldValue(obj, field, cascade, 0);
    }

    private static Boolean shouldIncludeField(
        final SObject obj,
        final Schema.SObjectField field,
        final Boolean cascade
    ) {
        final Schema.DescribeFieldResult fieldDescribe = field.getDescribe();
        return (
            fieldDescribe.getName() == 'IsActive' ||
            (
                fieldDescribe.isCreateable() &&
                !fieldDescribe.isDefaultedOnCreate() &&
                (
                    isIncludedField(obj, fieldDescribe) ||
                    (
                        (
                            FillAllFields ||
                            !fieldDescribe.isNillable() ||
                            (
                                // Always fill references with cascade if they are not nillable
                                cascade &&
                                fieldDescribe.getType() == Schema.DisplayType.Reference
                            )
                        ) &&
                        !isExcludedField(fieldDescribe) &&
                        !isExcludedField(obj, fieldDescribe) &&
                        !isPersonAccountField(fieldDescribe)
                    )
                )
            )
        );
    }

    static Long getRandomNumber() {
        return getRandomNumber(0L);
    }

    static Long getRandomNumber(final Long lowerBound) {
        return getRandomNumber(lowerBound, 1000L);
    }

    static Long getRandomNumber(
        final Long lowerBound,
        final Long range
    ) {
        final Double randomComponent = Math.random();
        return (lowerBound + 1L) * (1L + randomComponent * range).longValue() - 1L;
    }

    static Long getRandomNumberInRange(
        final Long lowerBound,
        final Long upperBound
    ) {
        final Double randomComponent = Math.random();
        return lowerBound + (randomComponent * upperBound).longValue();
    }

    public static void setNewValueForField(
        final SObject obj,
        final String fieldName
    ) {
        final String objectType = obj
            .getSObjectType()
            .getDescribe()
            .getName();
        final Schema.SObjectField field = fieldMapFor(objectType).get(fieldName);
        final Object newValue = getNewValueForField(obj, field, false, 0);
        obj.put(fieldName, newValue);
    }

    static Object getNewValueForField(
        final SObject obj,
        final Schema.SObjectField field,
        final Boolean cascade,
        final Integer counter
    ) {
        final Schema.SObjectType objectType = obj.getSObjectType();
        final Schema.DescribeFieldResult fieldDescribe = field.getDescribe();
        final Schema.DisplayType fieldType = fieldDescribe.getType();
        final String fieldName = fieldDescribe.getName();

        if (fieldType == Schema.DisplayType.Picklist) {
            // Picklist goes first, since there's potential values are ready to
            // be grabbed, and we can't really use any other value anyways
            return getNewPicklistValue(obj, field);
        } else if (fieldName.endsWith('Country')) {
            return getNewCountry();
        } else if (fieldName.endsWith('State')) {
            return getNewState();
        } else if (fieldName.endsWith('CountryCode')) {
            return getNewCountryCode();
        } else if (fieldName.endsWith('StateCode')) {
            return getNewStateCode();
        } else if (fieldName.endsWith('Latitude')) {
            return (Double) getRandomNumberInRange(-90L, 90L);
        } else if (fieldName.endsWith('Longitude')) {
            return (Double) getRandomNumberInRange(-180L, 180L);
        } else if (
            fieldType == Schema.DisplayType.URL ||
            fieldName.endsWith('Url')
        ) {
            final Long randomComponent = getRandomNumber(counter);
            return String.format(
                'http://test-{0}-{1}.com',
                new List<String> {
                    counter.format(),
                    randomComponent.format()
                }
            );
        } else if (fieldType == Schema.DisplayType.base64) {
            final Long randomComponent = getRandomNumber(counter);
            final String value = String.format(
                '{0}-{1}',
                new List<String> {
                    counter.format(),
                    randomComponent.format()
                }
            );
            return Blob.valueOf(value);
        } else if (fieldType == Schema.DisplayType.Boolean) {
            final Boolean prevValue = (Boolean) obj.get(field);
            return !prevValue;
        } else if (fieldType == Schema.DisplayType.Combobox) {
            final Long randomComponent = getRandomNumber(counter);
            return randomComponent.format();
        } else if (fieldType == Schema.DisplayType.Currency) {
            return getRandomNumber(counter);
        } else if (fieldType == Schema.DisplayType.Date) {
            final Integer randomComponent = getRandomNumber(counter, 365).intValue();
            return Date.today().addDays(-randomComponent);
        } else if (fieldType == Schema.DisplayType.DateTime) {
            final Integer randomComponent = getRandomNumber(counter, 365).intValue();
            return DateTime.now().addDays(-randomComponent);
        } else if (fieldType == Schema.DisplayType.Double) {
            return (Double) getRandomNumber(counter);
        } else if (
            fieldName == 'Username' ||
            fieldType == Schema.DisplayType.Email
        ) {
            final Long randomComponent = getRandomNumber(counter);
            return String.format(
                'test-{0}-{1}@test.com',
                new List<String> {
                    counter.format(),
                    randomComponent.format()
                }
            );
        } else if (fieldType == Schema.DisplayType.EncryptedString) {
            final Long randomComponent = getRandomNumber(counter);
            return randomComponent.format();
        } else if (fieldType == Schema.DisplayType.Id) {
            // Ignore, we don't specify ID's when creating objects.
        } else if (fieldType == Schema.DisplayType.Integer) {
            return getRandomNumber(counter, 30).intValue();
        } else if (fieldType == Schema.DisplayType.MultiPicklist) {
            return getNewPicklistValue(obj, field);
        } else if (fieldType == Schema.DisplayType.Percent) {
            final Long randomComponent = getRandomNumber(counter);
            return Math.mod(randomComponent, 100);
        } else if (fieldType == Schema.DisplayType.Phone) {
            final List<String> digits = new List<String>();
            for (Integer i = 0; i < 10; ++i) {
                final Integer digit = Math.mod(getRandomNumber().intValue(), 10);
                digits.add(digit.format());
            }
            return String.format('{0}{1}{2}-{3}{4}{5}-{6}{7}{8}{9}', digits);
        } else if (
            fieldName == 'CommunityNickname' &&
            fieldType == Schema.DisplayType.String
        ) {
            final Long randomComponent = getRandomNumber(counter);
            return String.format(
                'test{0}',
                new List<String> {
                    randomComponent.format()
                }
            );
        } else if (fieldType == Schema.DisplayType.String) {
            final Long randomComponent = getRandomNumber(counter);
            final Integer maxLength = fieldDescribe.getLength();
            final String preliminaryValue = String.format(
                'a{0}{1}',
                new List<String> {
                    counter.format(),
                    randomComponent.format()
                }
            );
            final Integer valueLength = Math.min(maxLength, preliminaryValue.length());
            return preliminaryValue.substring(0, valueLength);
        } else if (fieldType == Schema.DisplayType.Reference) {
            final String referenceObjectTypeName = fieldDescribe
                .getReferenceTo()[0]
                .getDescribe()
                .getName();
            final String objectTypeName = objectType
                .getDescribe()
                .getName();

            if (referenceObjectTypeName == 'RecordType') {
                return getRecordTypeId(objectType);
            } else if (referenceObjectTypeName == 'Profile') {
                return UserProfile.Id;
            } else if (
                cascade &&
                referenceObjectTypeName != objectTypeName &&
                referenceObjectTypeName != 'BusinessHours'
            ) {
                System.debug(
                    String.format(
                        'Creating reference to {0} for field {1}.{2}',
                        new List<String> {
                            referenceObjectTypeName,
                            objectTypeName,
                            fieldName
                        }
                    )
                );
                final SObject reference = createSObject(
                    referenceObjectTypeName,
                    cascade,
                    counter + 1,
                    false
                );
                if (reference == null) {
                    System.debug('Skipping instance of type ' + referenceObjectTypeName);
                    return null;
                }

                return reference.Id;
            }
        } else if (fieldType == Schema.DisplayType.TextArea) {
            return getRandomNumber(counter).format();
        } else if (fieldType == Schema.DisplayType.Time) {
            final Integer hour = Math.mod(getRandomNumber().intValue(), 24);
            final Integer minutes = Math.mod(getRandomNumber().intValue(), 60);
            final Integer seconds = Math.mod(getRandomNumber().intValue(), 60);
            final Integer milliseconds = Math.mod(getRandomNumber().intValue(), 1000);
            return Time.newInstance(hour, minutes, seconds, milliseconds);
        } else {
            System.debug('Unhandled field type ' + fieldType);
        }
        return null;
    }

    static void setFieldValue(
        final SObject obj,
        final Schema.SObjectField field,
        final Boolean cascade,
        final Integer counter
    ) {
        if (shouldIncludeField(obj, field, cascade)) {
            final Object value = getNewValueForField(obj, field, cascade, counter);
            obj.put(field, value);
        }
    }

    static ID getRecordTypeId(final SObjectType objectType) {
        final List<Schema.RecordTypeInfo> recordTypes = objectType
            .getDescribe()
            .getRecordTypeInfos();
        if (recordTypes.size() > 1) {   // All objects have default Master type
            for (Schema.RecordTypeInfo recordType : recordTypes) {
                if (recordType.isAvailable() && recordType.isDefaultRecordTypeMapping()) {
                    return recordType.getRecordTypeId();
                }
            }
        }
        return null;
    }

    static void setRecordType(final SObject obj) {
        final ID recordTypeId = getRecordTypeId(obj.getSObjectType());
        obj.put('RecordTypeId', recordTypeId);
    }
}
